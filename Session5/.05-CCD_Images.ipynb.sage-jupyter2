{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-0b1a5e6f-4dca-4f31-b828-7dce3340b25f.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_backend_state":1734522738452,"last_ipynb_save":1734523421822,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.10.12"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1734361988367,"exec_count":44,"id":"814764","input":"plot_astro_image(V_30_calib_image, B_300_calib_image, V_30_calib_hdr, B_300_calib_hdr, \"gray\", \"lower\", \"linear\")\n","kernel":"python3","output":{"0":{"name":"stdout","text":"Raw image mean is 1337.8 counts and STD is 377.6\nCalibrated image mean is 4684.4 counts and STD is 728.7\n"},"1":{"data":{"image/png":"ec420351a946dfa055e54f395dcd0aceb8b42adf","text/plain":"<Figure size 1800x1800 with 2 Axes>"},"metadata":{"image/png":{"height":473,"width":1435},"needs_background":"light"}}},"pos":84,"start":1734361986551,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437079304,"exec_count":111,"id":"a27a41","input":"print(reduced_images.summary)","kernel":"python3","last":57,"output":{"0":{"name":"stdout","text":"        file          imagetyp  exposure filter master\n------------------- ----------- -------- ------ ------\n         bias_1.fit  Bias Frame      0.0     --     --\n         bias_2.fit  Bias Frame      0.0     --     --\n         bias_3.fit  Bias Frame      0.0     --     --\n     dark_300_1.fit  Dark Frame    300.0     --     --\n     dark_300_2.fit  Dark Frame    300.0     --     --\n     dark_300_3.fit  Dark Frame    300.0     --     --\n      dark_30_1.fit  Dark Frame     30.0     --     --\n      dark_30_2.fit  Dark Frame     30.0     --     --\n      dark_30_3.fit  Dark Frame     30.0     --     --\n       flat_b_1.fit  Flat Field      7.0      B     --\n                ...         ...      ...    ...    ...\nngc7789_b_300_2.fit Light Frame    300.0      B     --\nngc7789_b_300_3.fit Light Frame    300.0      B     --\n ngc7789_b_30_1.fit Light Frame     30.0      B     --\n ngc7789_b_30_2.fit Light Frame     30.0      B     --\n ngc7789_b_30_3.fit Light Frame     30.0      B     --\nngc7789_v_300_1.fit Light Frame    300.0      V     --\nngc7789_v_300_2.fit Light Frame    300.0      V     --\nngc7789_v_300_3.fit Light Frame    300.0      V     --\n ngc7789_v_30_1.fit Light Frame     30.0      V     --\n ngc7789_v_30_2.fit Light Frame     30.0      V     --\n ngc7789_v_30_3.fit Light Frame     30.0      V     --\nLength = 32 rows\n"}},"pos":64,"start":1734437079285,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437080149,"exec_count":112,"id":"7b0b17","input":"#destination_dir = root_folder + 'calib_data'\ndata_reduction = Reduction(bias_subtract=True, # subtract bias from frames\n                           dark_subtract=True, # subtract darks from frames\n                           flat_correct=True, #  divide by flat field \n                           master_source=reduced_images, # look in `reduced_images`\n                           input_image_collection=images, # Use raw images as image collecion  \n                           destination=destination_folder, # send calibrated images to destination_folder\n                           apply_to={'imagetyp': 'light frame'}\n                          )\ndata_reduction.action()","kernel":"python3","last":3282,"metadata":{"deletable":false},"pos":66,"start":1734437079385,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437080164,"exec_count":113,"id":"bbe3ac","input":"import astroalign\n\ndef image_stack(image_list):\n    \"\"\"\n    Stacks a list of FITS files using astroalign.\n\n    Parameters\n    ----------\n    image_list: list of strings\n        A list of FITS file names\n\n    Returns\n    -------\n    stacked_image: numpy.ndarray\n        The stacked (averaged) image\n    image_hdr: astropy.io.fits.Header\n        A FITS header you can use to write image out to FITS files\n    \"\"\"\n    # defensive programming, check all the files exist before continuing\n    for filename in image_list:\n        if not os.path.exists(filename):\n            raise ValueError('filename {} does not exist'.format(filename))\n\n    # read in first image and header to use as reference\n    ref_im, ref_hdr = fits.getdata(image_list[0], header=True)\n    ref_im = ref_im.astype('float')\n\n    # make an empty list to store aligned images\n    aligned_ims = []\n    for filename in image_list[1:]:  # loop over all images (except the first, reference, image)\n        image = fits.getdata(filename).astype('float')  # read FITS file into numpy array\n        aligned_image, _ = astroalign.register(image, ref_im)  # align to reference\n        aligned_ims.append(aligned_image)  # add to list of aligned images\n\n    # average by summing and dividing by number of images\n    ref_im = ref_im.astype('float')\n    for image in aligned_ims:\n        ref_im += image\n    ref_im /= len(aligned_ims) + 1\n    return ref_im, ref_hdr","kernel":"python3","last":1558,"metadata":{"deletable":false},"pos":68,"start":1734437080161,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437080189,"exec_count":114,"id":"fdff13","input":"def sort_images(filtername, exposure, source=reduced_images):\n    \"\"\"\n    Queries data set using filter used and exposure time \n    \n    Parameters\n    ----------      \n    folder: folder name to be used \n        A string for the folder name to use \n\n    filtername: Filter used \n    \n    exposure: exposure time [sec]\n        Exposure time of FITS file in seconds \n        \n    source: Image source \n        A Image file colletion of source images, default value is 'reduced_images' which is a collection of calibrated images, set source as 'images' to query uncalibrated/raw images\n        \n    Returns\n    -------\n    imageset: List \n        Returns a list of full file paths of queried FITS files from dataset that match input filter and exposure time from specfied image source\n    \"\"\"\n        \n    # Create variable to store full directory path of all light frame images of input filter and exposure times and send to created folder \n    imageset = source.files_filtered(imagetyp='Light Frame', filter=f'{filtername}', exposure=exposure, include_path=True)\n    \n    #Return lists of file paths \n    return imageset","kernel":"python3","last":4,"pos":70,"start":1734437080179,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437080206,"exec_count":115,"id":"38496e","input":" #Create 4 lists for the calibrated images  \nV_30_calib = sort_images(\"V\" ,30)\nV_300_calib = sort_images(\"V\" ,300)\nB_30_calib = sort_images(\"B\" ,30)\nB_300_calib = sort_images(\"B\" ,300)\n\n\n#Create 4 lists for raw images (specify 'images' for image source)\nV_30_raw = sort_images(\"V\" ,30, images)\nV_300_raw = sort_images(\"V\" ,300, images)\nB_30_raw = sort_images(\"B\" ,30, images)\nB_300_raw = sort_images(\"B\" ,300, images)","kernel":"python3","last":4,"pos":71,"start":1734437080201,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437092378,"exec_count":116,"id":"4165ea","input":"# Use image_stack function to stack 4 calbrated lists \nV_30_calib_image, V_30_calib_hdr = image_stack(V_30_calib)\nV_300_calib_image, V_300_calib_hdr  = image_stack(V_300_calib)\nB_30_calib_image, B_30_calib_hdr = image_stack(B_30_calib)\nB_300_calib_image, B_300_calib_hdr = image_stack(B_300_calib)\n\n\n\n# Use image_stack function to stack 4 raw lists \nV_30_raw_image, V_30_raw_hdr = image_stack(V_30_raw)\nV_300_raw_image, V_300_raw_hdr  = image_stack(V_300_raw)\nB_30_raw_image, B_30_raw_hdr = image_stack(B_30_raw)\nB_300_raw_image, B_300_raw_hdr = image_stack(B_300_raw)","kernel":"python3","last":10003,"pos":72,"start":1734437080212,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437092395,"exec_count":117,"id":"962d73","input":"def upload_fits_image(filename, data, header):\n    \"\"\"\n    Uploads stacked fits file to named folder\n    \n    Parameters\n    ----------      \n    filename: name of file to save image to \n    String value of file name \n    \n    data: Image data retrieved from stacked image\n    \n    header: Header data retrieved from stacked image \n    \n    -------\n    Returns:\n    None\n    \n    \"\"\"\n    dest_folder = root_folder + filename # Create dest_folder variable\n\n    hdu2 = fits.PrimaryHDU(data=data, header=header)\n    hdu2.writeto(f'{dest_folder}', overwrite=True)\n    \n    return None ","kernel":"python3","last":2,"pos":73,"start":1734437092387,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437092521,"exec_count":118,"id":"025a35","input":"#upload 4 calibrated images \nupload_fits_image(\"V_30_calib\",V_30_calib_image, V_30_calib_hdr)\nupload_fits_image(\"V_300_calib\",V_300_calib_image, V_300_calib_hdr)\nupload_fits_image(\"B_30_calib\",B_30_calib_image, B_30_calib_hdr)\nupload_fits_image(\"B_300_calib\",B_300_calib_image, B_300_calib_hdr)\n\n\n#upload 4 raw images \nupload_fits_image(\"V_30_raw\",V_30_raw_image, V_30_raw_hdr)\nupload_fits_image(\"V_300_raw\",V_300_raw_image, V_300_raw_hdr)\nupload_fits_image(\"B_30_raw\",B_30_raw_image, B_30_raw_hdr)\nupload_fits_image(\"B_300_raw\",B_300_raw_image, B_300_raw_hdr)","kernel":"python3","last":140,"pos":74,"start":1734437092410,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437092546,"exec_count":119,"id":"6f1979","input":"def plot_astro_image(raw_image, calib_image, raw_hdr, calib_hdr, cmap, origin, norm, aspect=\"equal\"):\n    \"\"\"\n    Plots 2 images side by side, Raw image appears on LHS and calibrated image appears on RHS\n    \n    Parameters\n    -----------\n    raw_image: Image data of raw image \n    2D NumPy array of raw image data, created when image_stack function is called \n    \n    calib_image: Image data of calibrated image \n    2D NumPy array of calibrated image data, created when image_stack function is called \n    \n    raw_hdr: Header data for raw image\n    Passed into raw plot title \n    \n    calib_hdr: Header data for calibrated image\n    Passed into calibrated  plot title\n    \n    cmap: Colour map instance for image \n    String value to specify colour map of image \n    \n    origin:\n    Place the [0, 0] index of the array in the upper left or lower left corner of the Axes\n    \n    norm: \n    The normalization method used to scale scalar data to the [0, 1] range before mapping to colors using cmap\n    \n    aspect:\n    The aspect ratio of the Axes, default is 'equal'\n    -------------------\n    Returns \n    None\n    \n    \"\"\"\n    \n   #Calculate mean and STD for raw and calibrated images\n    raw_mean = raw_image.mean()\n    raw_std = raw_image.std()\n    calib_mean = calib_image.mean()\n    calib_std = calib_image.std()\n    \n    \n   # Store exposure time and filter used for plot title \n    raw_exposure  = raw_hdr['exposure']\n    raw_filter = raw_hdr[\"filter\"]\n    calib_exposure  = calib_hdr['exposure']\n    calib_filter = calib_hdr[\"filter\"]\n    \n    #Create figure axis and plot both raw and calibrated images\n    fig, axis = plt.subplots(figsize=(25, 25), nrows=1, ncols=2)\n    vmin,vmax = np.percentile(masterflat_im, [5,95])\n    axis[0].imshow(raw_image, cmap=cmap, origin=origin, norm=norm, aspect=aspect, vmin=vmin, vmax=vmax)\n    axis[1].imshow(calib_image,cmap=cmap, origin=origin, norm=norm, aspect=aspect, vmin=vmin, vmax=vmax)\n    axis[0].grid(False)\n    axis[1].grid(False)\n\n    #Figure titles\n    axis[0].set_title(f\"NGC 7789 {raw_filter} filter {raw_exposure} second exposure (Raw image)\")\n    axis[1].set_title(f\"NGC 7789 {calib_filter} filter {calib_exposure} second exposure (Calibrated image)\")\n\n    \n    #Show mean counts and STD for both raw and calibrated images \n    print(f\"Raw image mean is {raw_mean:.1f} counts and STD is {raw_std:.1f}\")\n    print(f\"Calibrated image mean is {calib_mean:.1f} counts and STD is {calib_std:.1f}\")\n    plt.show()\n    \n    return None","kernel":"python3","last":9,"pos":76,"start":1734437092534,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437093839,"exec_count":120,"id":"65e3b9","input":"#Use plot_image function for V filter 30 second Exposure time\nplot_astro_image(V_30_raw_image, V_30_calib_image, V_30_raw_hdr, V_30_calib_hdr, \"viridis\", \"lower\", \"linear\")","kernel":"python3","last":1253,"output":{"0":{"name":"stdout","text":"Raw image mean is 2288.6 counts and STD is 386.6\nCalibrated image mean is 1337.8 counts and STD is 377.6\n"},"1":{"data":{"image/png":"b764310aa7474b5a583208ca5221c33b6f371d5e","text/plain":"<Figure size 1800x1800 with 2 Axes>"},"metadata":{"image/png":{"height":473,"width":1435},"needs_background":"light"}}},"pos":77,"start":1734437092580,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437096439,"exec_count":122,"id":"4b38cd","input":"#Use plot_image function for V filter 300 second Exposure time\nplot_astro_image(V_300_raw_image, V_300_calib_image, V_300_raw_hdr, V_300_calib_hdr, \"viridis\", \"lower\", \"linear\")","kernel":"python3","last":1613,"output":{"0":{"name":"stdout","text":"Raw image mean is 13800.5 counts and STD is 1999.2\nCalibrated image mean is 12839.3 counts and STD is 1964.7\n"},"1":{"data":{"image/png":"553cb2c39b329f76dfce9d9a428c241ff4f320c1","text/plain":"<Figure size 1800x1800 with 2 Axes>"},"metadata":{"image/png":{"height":473,"width":1435},"needs_background":"light"}}},"pos":78,"start":1734437095120,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437894592,"exec_count":127,"id":"d3e7dc","input":"#Use plot_image function for B filter 30 second Exposure time\nplot_astro_image(B_30_raw_image, B_30_calib_image, B_30_raw_hdr, B_30_calib_hdr, \"viridis\", \"lower\", \"linear\")","kernel":"python3","last":1268,"output":{"0":{"name":"stdout","text":"Raw image mean is 1444.0 counts and STD is 112.8\nCalibrated image mean is 493.3 counts and STD is 97.6\n"},"1":{"data":{"image/png":"494f827790df8e27fa16e5816470a92562c4fa69","text/plain":"<Figure size 1800x1800 with 2 Axes>"},"metadata":{"image/png":{"height":473,"width":1435},"needs_background":"light"}}},"pos":79,"start":1734437893347,"state":"done","type":"cell"}
{"cell_type":"code","end":1734437900314,"exec_count":128,"id":"124708","input":"#Use plot_image function for B filter 300 second Exposure time\nplot_astro_image(B_300_raw_image, B_300_calib_image, B_300_raw_hdr, B_300_calib_hdr, \"viridis\", \"lower\", \"linear\")","kernel":"python3","last":1408,"output":{"0":{"name":"stdout","text":"Raw image mean is 5644.6 counts and STD is 761.5\nCalibrated image mean is 4684.4 counts and STD is 728.7\n"},"1":{"data":{"image/png":"30f0ac5813cf8b88fbc369c392b73c0dae9a3a2e","text/plain":"<Figure size 1800x1800 with 2 Axes>"},"metadata":{"image/png":{"height":473,"width":1435},"needs_background":"light"}}},"pos":80,"start":1734437898304,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522738492,"exec_count":3,"id":"dc6162","input":"from IPython.core.display import HTML\ncss_file = '../../styles/styles.css'\nHTML(open(css_file, \"r\").read())","kernel":"python3","last":10,"output":{"0":{"data":{"text/html":"<link href='http://fonts.googleapis.com/css?family=Crimson+Text' rel='stylesheet' type='text/css'>\n<link href='http://fonts.googleapis.com/css?family=Kameron' rel='stylesheet' type='text/css'>\n<link href='http://fonts.googleapis.com/css?family=Lato:200,300,400' rel='stylesheet' type='text/css'>\n<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'>\n<style>\n\n@font-face {\n    font-family: \"Computer Modern\";\n    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunss.otf');\n}\n\n#notebook_panel { /* main background */\n    background: rgb(245,245,245);\n}\n\n\ndiv #notebook { /* centre the content */\n    background: #fff; /* white background for content */\n    margin: auto;\n    padding-left: 0em;\n}\n\n\n#notebook li { /* More space between bullet points */\n    margin-top:0.8em;\n}\n\n/* draw border around running cells */\ndiv.cell.border-box-sizing.code_cell.running { \n    border: 1px solid #111;\n}\n\n/* Put a solid color box around each cell and its output, visually linking them*/\ndiv.cell.code_cell {\n    background-color: rgb(256,256,256); \n    border-radius: 0px; \n    /* width: 105ex; */\n    padding: 0.5em;\n    margin-left:1em;\n    margin-top: 1em;\n}\n\ndiv.input_area {\n    border-color: rgba(0,0,0,0.10);\n    background: rbga(0,0,0,0.5);\n}\n\n/*\ndiv.text_cell {\n    max-width: 105ex; /* instead of 100%, */\n}\n*/\n\ndiv.text_cell_render {\n    font-family: \"Crimson Text\";\n    font-size: 12pt;\n    line-height: 145%; /* added for some line spacing of text. */\n}\n\ndiv.text_cell_render h1,\ndiv.text_cell_render h2,\ndiv.text_cell_render h3,\ndiv.text_cell_render h4,\ndiv.text_cell_render h5,\ndiv.text_cell_render h6 {\n    font-family: 'Kameron';\n    font-weight: 300;\n}\n\ndiv.text_cell_render h1 {\n    font-size: 24pt;\n}\n\ndiv.text_cell_render h2 {\n    font-size: 18pt;\n}\n\ndiv.text_cell_render h3 {\n    font-size: 14pt;\n}\n\n.rendered_html pre,\n.rendered_html code {\n    font-size: medium;\n    background-color: rgba(246,246,246,1);\n    padding: 2px;\n}\n\n.rendered_html ol {\n    list-style:decimal;\n    margin: 1em 2em;\n}\n\n.CodeMirror pre{\n        font-family: 'Source Code Pro', Consolas, monocco, monospace;\n}\n\n/* Make space between the fa icon and the rest of the header */\n.panel-heading h1 span,\n.panel-heading h2 span,\n.panel-heading h3 span,\n.panel-heading h4 span,\n.panel-heading h5 span,\n.panel-heading h6 span {\n    padding-right: 10px;\n}\n\n.fa {\n    padding: 5px;\n    }\n   \nkbd {\n    padding:0.1em 0.6em;\n    border:1px solid #ccc;\n    font-size:11px;\n    font-family:Arial,Helvetica,sans-serif;\n    background-color:#f7f7f7;\n    color:#333;\n    -moz-box-shadow:0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;\n    -webkit-box-shadow:0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;\n    box-shadow:0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;\n    -moz-border-radius:3px;\n    -webkit-border-radius:3px;\n    border-radius:3px;\n    display:inline-block;\n    margin:0 0.1em;\n    text-shadow:0 1px 0 #fff;\n    line-height:1.4;\n    white-space:nowrap;\n}\n\n</style>\n<script>\n    MathJax.Hub.Config({\n                        TeX: {\n                           extensions: [\"AMSmath.js\"],\n                           equationNumbers: { autoNumber: \"AMS\", useLabelIds: true}\n                           },\n                tex2jax: {\n                    inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n                    displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ]\n                },\n                displayAlign: 'center', // Change this to 'center' to center equations.\n                \"HTML-CSS\": {\n                    styles: {'.MathJax_Display': {\"margin\": 4}}\n                }\n        });\n</script>","text/plain":"<IPython.core.display.HTML object>"},"exec_count":3}},"pos":1,"start":1734522738485,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522742997,"exec_count":4,"id":"70d620","input":"# The \"fits\" library contains functions for reading and writing FITS files.\nfrom astropy.io import fits\n\n# let's also import some standard modules\nimport numpy as np\n# display plots in notebook\n%matplotlib inline\nimport matplotlib.pyplot as plt","kernel":"python3","last":4,"pos":7,"start":1734522738518,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522743024,"exec_count":5,"id":"a90312","input":"image_file = '../../data/Session2/pleiades.fits'\nimage_data = fits.getdata(image_file)\nimage_hdr  = fits.getheader(image_file)","kernel":"python3","last":8,"pos":9,"start":1734522743010,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522743043,"exec_count":6,"id":"feda92","input":"print(type(image_data))\nprint(image_data.shape)","kernel":"python3","last":5,"output":{"0":{"name":"stdout","text":"<class 'numpy.ndarray'>\n(875, 875)\n"}},"pos":11,"start":1734522743031,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522745667,"exec_count":7,"id":"e99958","input":"fig, axis = plt.subplots(figsize=(5, 5))\nimplot = axis.imshow(image_data, cmap='gray', origin='lower')\naxis.grid(False)\nplt.show()","kernel":"python3","last":692,"output":{"0":{"data":{"image/png":"9fd88ebc4dc52042b156b12c80dfc60ce1f2b953","text/plain":"<Figure size 360x360 with 1 Axes>"},"metadata":{"image/png":{"height":302,"width":312},"needs_background":"light"}}},"pos":13,"start":1734522743077,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522745680,"exec_count":8,"id":"48202a","input":"image_hdr","kernel":"python3","last":80,"output":{"0":{"data":{"text/plain":"SIMPLE  =                    T / file does conform to FITS standard             \nBITPIX  =                    8 / number of bits per data pixel                  \nNAXIS   =                    2 / number of data axes                            \nNAXIS1  =                  875 / length of data axis 1                          \nNAXIS2  =                  875 / length of data axis 2                          \nBZERO   =                   0. / PhysValue = BZERO + BSCALE * ArrayValue        \nBSCALE  =            0.0001526 / PhysValue = BZERO + BSCALE * ArrayValue        \nCOMMENT Standard WCS reduction:                                                 \nCRVAL1  =     56.7489909930614 / WCS Ref value (RA in decimal degrees)          \nCRVAL2  =     24.1176620538817 / WCS Ref value (DEC in decimal degrees)         \nCRPIX1  =                437.5 / WCS Coordinate reference pixel                 \nCRPIX2  =                437.5 / WCS Coordinate reference pixel                 \nCD1_1   = -0.00188528106045289 / WCS Coordinate scale matrix                    \nCD1_2   = 4.64238235046548E-05 / WCS Coordinate scale matrix                    \nCD2_1   = 4.64238235046548E-05 / WCS Coordinate scale matrix                    \nCD2_2   =  0.00188528106045289 / WCS Coordinate scale matrix                    \nCTYPE1  = 'RA---TAN'           / WCS Coordinate type                            \nCTYPE2  = 'DEC--TAN'           / WCS Coordinate type                            \nEQUINOX =                2000. / Equinox                                        \nRADESYS = 'FK5     '           / Coordinate system                              \nMJD-OBS =     33979.2770833333 / Modified Julian Date at start of observation   \nEPOCH   =     1951.90904061145 /  Epoch in Julian Year at start of observation  \nCUNIT1  = 'DEG     '           / RA Coordinate Unit                             \nCUNIT2  = 'DEG     '           / DEC Coordinate Unit                            \nCDELT1  =  0.00188585255210771 / WCS Coordinate scale matrix                    \nCDELT2  =  0.00188585255210771 / WCS Coordinate scale matrix                    \nCOMMENT Standard WCS reduction:                                                 \nBUNIT   = 'TRANSMISSION'       / UNITE                                          \nOBJECT  = 'GLOBAL'             /                                                \nDATE    = '00/00/00'           / DATE D'ECRITURE DU FICHIER                     \nORIGIN  = 'CDS'                / Centre de Donnees astronomiques de Strasbourg  \nINSTRUME= 'STScI'               /                                               \nCDELTA  =                101.1 / INCREMENT LE LONG DE L'AXE DES X               \nCTYPEA  = 'MICRON'             / TYPE DE LA COORDONNEE X                        \nCDELTB  =                101.1 / INCREMENT LE LONG DE L'AXE DES Y               \nCTYPEB  = 'MICRON'             / TYPE DE LA COORDONNEE Y                        \nCRVALA  =                  0.0 / EN MICRON : COORDONNEE 1 DU PIXEL ORIGINE      \nCRVALB  =             176991.1 / EN MICRON : COORDONNEE 2 DU PIXEL ORIGINE      \nNUM     = 'NONE'               /                                                \nCNPIX1  =                   39 / New CNPIX1                                     \nCNPIX2  =                 1174 / New CNPIX2                                     "},"exec_count":8}},"pos":15,"start":1734522745675,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522745697,"exec_count":9,"id":"0683e4","input":"print( image_hdr['MJD-OBS'] )","kernel":"python3","last":10,"output":{"0":{"name":"stdout","text":"33979.2770833333\n"}},"pos":17,"start":1734522745694,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522745718,"exec_count":10,"id":"896e91","input":"hdu = fits.PrimaryHDU(data=image_data)\nhdu.writeto('my_new_fits_file.fits', overwrite=True)","kernel":"python3","last":5,"pos":19,"start":1734522745717,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522745760,"exec_count":11,"id":"ee650c","input":"hdu = fits.PrimaryHDU(data=image_data, header=image_hdr)\nhdu.writeto('my_new_fits_file.fits', overwrite=True)","kernel":"python3","last":6,"pos":21,"start":1734522745739,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522751563,"exec_count":12,"id":"57a31e","input":"import ccdproc # the ccdproc library\nfrom reduction_tools import Combiner, Reduction # my custom tools for combining and `reducing` CCD data.","kernel":"python3","last":3,"pos":23,"start":1734522745768,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522751580,"exec_count":13,"id":"8bc5ca","input":"root_folder = '/home/user/PHY241/observing_project/'\ndata_folder = root_folder + 'raw_data'\ndestination_folder = root_folder + 'calib_data'\n\nimport os  # the os library contains functions for working with the file system\n\n# make root folder ONLY if it does not exist\nif not os.path.exists(root_folder):\n    os.mkdir(root_folder)\n\n# make destination directory ONLY if it does not exist\nif not os.path.exists(destination_folder):\n    os.mkdir(destination_folder)\n\n# make data directory ONLY if it does not exist\nif not os.path.exists(data_folder):\n    os.mkdir(data_folder)","kernel":"python3","last":3,"pos":25,"start":1734522751575,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522751843,"exec_count":14,"id":"a4c9e6","input":"images = ccdproc.ImageFileCollection(location=data_folder, keywords=['imagetyp', 'exposure', 'filter'])","kernel":"python3","last":178,"pos":28,"start":1734522751584,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522751865,"exec_count":15,"id":"922579","input":"print(images.summary)","kernel":"python3","last":10,"output":{"0":{"name":"stdout","text":"        file          imagetyp  exposure filter\n------------------- ----------- -------- ------\n         bias_1.fit  Bias Frame      0.0     --\n         bias_2.fit  Bias Frame      0.0     --\n         bias_3.fit  Bias Frame      0.0     --\n     dark_300_1.fit  Dark Frame    300.0     --\n     dark_300_2.fit  Dark Frame    300.0     --\n     dark_300_3.fit  Dark Frame    300.0     --\n      dark_30_1.fit  Dark Frame     30.0     --\n      dark_30_2.fit  Dark Frame     30.0     --\n      dark_30_3.fit  Dark Frame     30.0     --\n       flat_b_1.fit  Flat Field      7.0      B\n                ...         ...      ...    ...\nngc7789_b_300_2.fit Light Frame    300.0      B\nngc7789_b_300_3.fit Light Frame    300.0      B\n ngc7789_b_30_1.fit Light Frame     30.0      B\n ngc7789_b_30_2.fit Light Frame     30.0      B\n ngc7789_b_30_3.fit Light Frame     30.0      B\nngc7789_v_300_1.fit Light Frame    300.0      V\nngc7789_v_300_2.fit Light Frame    300.0      V\nngc7789_v_300_3.fit Light Frame    300.0      V\n ngc7789_v_30_1.fit Light Frame     30.0      V\n ngc7789_v_30_2.fit Light Frame     30.0      V\n ngc7789_v_30_3.fit Light Frame     30.0      V\nLength = 27 rows\n"}},"pos":30,"start":1734522751857,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522752079,"exec_count":16,"id":"c7168d","input":"# define the Reduction task\ncopy_file_task = Reduction(input_image_collection=images, \n                           destination=destination_folder, \n                           apply_to={'imagetyp': 'Bias Frame'},\n                           copy_only=True)\n\n# the line above simply creates the Reduction task object. To run it, call it's `action` function, like so\ncopy_file_task.action()","kernel":"python3","last":194,"pos":33,"start":1734522751870,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522753138,"exec_count":17,"id":"791556","input":"reduced_images = ccdproc.ImageFileCollection(location=destination_folder, keywords=['imagetyp', 'exposure', 'filter', 'master'])\n\nmake_master_bias = Combiner(image_source=reduced_images,\n                            file_name_base='master_bias',\n                            combine_method='average',\n                            apply_to={'imagetyp':'Bias Frame'},\n                            destination=destination_folder)\nmake_master_bias.action()","kernel":"python3","last":422,"pos":35,"start":1734522752096,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522753219,"exec_count":18,"id":"a67079","input":"os.listdir(destination_folder)","kernel":"python3","last":23,"output":{"0":{"data":{"text/plain":"['ngc7789_v_30_3.fit',\n 'bias_2.fit',\n 'master_flat_filter_B.fit',\n 'ngc7789_v_300_1.fit',\n 'ngc7789_b_300_3.fit',\n 'dark_30_2.fit',\n 'ngc7789_b_30_1.fit',\n 'ngc7789_b_300_2.fit',\n 'master_bias.fit',\n 'master_dark_exposure_300.0.fit',\n 'ngc7789_v_30_2.fit',\n 'master_dark_exposure_30.0.fit',\n 'bias_3.fit',\n 'master_flat_filter_V.fit',\n 'flat_v_1.fit',\n 'dark_300_1.fit',\n 'dark_30_3.fit',\n 'flat_b_1.fit',\n 'flat_v_2.fit',\n 'ngc7789_b_30_3.fit',\n 'dark_300_2.fit',\n 'flat_b_2.fit',\n 'ngc7789_v_300_3.fit',\n 'ngc7789_b_300_1.fit',\n 'ngc7789_v_30_1.fit',\n 'dark_30_1.fit',\n 'flat_b_3.fit',\n 'dark_300_3.fit',\n 'ngc7789_b_30_2.fit',\n 'flat_v_3.fit',\n 'bias_1.fit',\n 'ngc7789_v_300_2.fit']"},"exec_count":18}},"pos":37,"start":1734522753202,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522753244,"exec_count":19,"id":"55edfc","input":"print(destination_folder, type(destination_folder))\nprint(os.path.join(destination_folder, 'bias_1.fit'))","kernel":"python3","last":4,"output":{"0":{"name":"stdout","text":"/home/user/PHY241/observing_project/calib_data <class 'str'>\n/home/user/PHY241/observing_project/calib_data/bias_1.fit\n"}},"pos":38,"scrolled":true,"start":1734522753230,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522755559,"exec_count":20,"id":"c6584e","input":"# use 'os' Python module to glue directories and filenames together easily\nfilepath = os.path.join(destination_folder, 'master_bias.fit')\nprint(filepath)\n\n# open the file and store data in array called 'masterbias'\nmasterbias = fits.getdata(filepath)\n\n# What's the mean level in the bias image?\nprint('The masterbias has mean level of {:.1f} counts'.format( masterbias.mean() ))\n\n# display it\nfig, axis = plt.subplots(figsize=(7, 7))\naxis.set_title(\"master bias frame\")\n\n# custom scaling - see companion notebook\nvmin,vmax = np.percentile(masterbias, [1,99])\nimplot = axis.imshow(masterbias, cmap='viridis', origin='lower', vmin=vmin, vmax=vmax)\naxis.grid(False)\nplt.show()\nfig.savefig('master_bias.png')","kernel":"python3","last":825,"output":{"0":{"name":"stdout","text":"/home/user/PHY241/observing_project/calib_data/master_bias.fit\nThe masterbias has mean level of 949.2 counts\n"},"1":{"data":{"image/png":"ef12685a7330df7f9fb3ab1c0874b717c1eeac8c","text/plain":"<Figure size 504x504 with 1 Axes>"},"metadata":{"image/png":{"height":309,"width":431},"needs_background":"light"}}},"pos":41,"start":1734522753264,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522755584,"exec_count":21,"id":"97a909","input":"# CALCULATE VALUES FOR MEAN AND STD DEV OF MASTER BIAS HERE\n# REMEMBER, THE DATA IS READ INTO NUMPY ARRAYS, SO ALL THE USUAL ARRAY METHODS WILL WORK\nprint(np.mean(masterbias))\nprint(np.std(masterbias))\n\n# Here's how to make a variable containing the \"path\" to a single bias frame\nsinglebiaspath = os.path.join(destination_folder, 'bias_1.fit')\nsingle_bias = fits.getdata(singlebiaspath)\n# NOW USE the astropy fits library to read in the data from this file\n\n# CALCULATE VALUES FOR MEAN AND STD DEV OF SINGLE BIAS HERE\nprint(np.mean(single_bias), np.std(single_bias))","kernel":"python3","last":16,"output":{"0":{"name":"stdout","text":"949.2313\n8.3221\n949.28174 12.610847\n"}},"pos":43,"start":1734522755566,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522756002,"exec_count":22,"id":"c48104","input":"dark_preprocessing = Reduction(bias_subtract=True,  # subtract bias from frames\n                               dark_subtract=False,  # don't subtract darks\n                               flat_correct=False,  # don't divide by flat field\n                               master_source=reduced_images,  # look in `reduced_images` for master frames to use\n                               input_image_collection=images,  # look in `images` for frames to work on\n                               destination=destination_folder,  # write output files to `destination_dir`\n                               apply_to={'imagetyp': 'dark frame'})  # only operate on frames with `imagetyp` equal to `dark frame`\ndark_preprocessing.action()","kernel":"python3","last":439,"pos":46,"start":1734522755590,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522758997,"exec_count":23,"id":"43aa16","input":"make_master_dark = Combiner(file_name_base='master_dark',\n                            combine_method='median',\n                            image_source=reduced_images,\n                            apply_to={'imagetyp':'dark frame'},\n                            group_by='exposure',\n                            destination=destination_folder)\nmake_master_dark.action()","kernel":"python3","last":1376,"pos":48,"start":1734522756021,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522759021,"exec_count":24,"id":"010780","input":"os.listdir(destination_folder)","kernel":"python3","last":3,"output":{"0":{"data":{"text/plain":"['ngc7789_v_30_3.fit',\n 'bias_2.fit',\n 'master_flat_filter_B.fit',\n 'ngc7789_v_300_1.fit',\n 'ngc7789_b_300_3.fit',\n 'dark_30_2.fit',\n 'ngc7789_b_30_1.fit',\n 'ngc7789_b_300_2.fit',\n 'master_bias.fit',\n 'master_dark_exposure_300.0.fit',\n 'ngc7789_v_30_2.fit',\n 'master_dark_exposure_30.0.fit',\n 'bias_3.fit',\n 'master_flat_filter_V.fit',\n 'flat_v_1.fit',\n 'dark_300_1.fit',\n 'dark_30_3.fit',\n 'flat_b_1.fit',\n 'flat_v_2.fit',\n 'ngc7789_b_30_3.fit',\n 'dark_300_2.fit',\n 'flat_b_2.fit',\n 'ngc7789_v_300_3.fit',\n 'ngc7789_b_300_1.fit',\n 'ngc7789_v_30_1.fit',\n 'dark_30_1.fit',\n 'flat_b_3.fit',\n 'dark_300_3.fit',\n 'ngc7789_b_30_2.fit',\n 'flat_v_3.fit',\n 'bias_1.fit',\n 'ngc7789_v_300_2.fit']"},"exec_count":24}},"pos":50,"start":1734522759016,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522761186,"exec_count":25,"id":"41659f","input":"filepath = os.path.join(destination_folder, \"master_dark_exposure_30.0.fit\")\n\nmasterdark_im = fits.getdata(filepath)\n\n# What's the mean level in the dark image?\nprint('The masterdark has mean level of {:.1f} counts'.format( masterdark_im.mean() ))\n\n# display it\nfig, axis = plt.subplots(figsize=(9, 9))\naxis.set_title(\"master dark (300s exposure time)\")\n# custom scaling - see companion notebook\nvmin,vmax = np.percentile(masterdark_im, [1,99])\nimplot = axis.imshow(masterdark_im,cmap='gray',origin='lower',vmin=vmin,vmax=vmax)\naxis.grid(False)\nplt.show()\nfig.savefig('master_dark.png')","kernel":"python3","last":1646,"output":{"0":{"name":"stdout","text":"The masterdark has mean level of 1.3 counts\n"},"1":{"data":{"image/png":"9ea05b8acfd1c84d19b670c8a7092b00da4efb59","text/plain":"<Figure size 648x648 with 1 Axes>"},"metadata":{"image/png":{"height":384,"width":542},"needs_background":"light"}}},"pos":52,"start":1734522759027,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522761198,"exec_count":26,"id":"bfa2f7","input":"# use os.path.join to glue together directory and filename\ndark_fits_filename = os.path.join(destination_folder, 'dark_300_1.fit') # you may need to change the file name here to match yours...\nimg_hdr = fits.getheader(dark_fits_filename) # read in FITS header using astropy's fits library\nprint(img_hdr['EXPOSURE'])","kernel":"python3","last":8,"output":{"0":{"name":"stdout","text":"300.0\n"}},"pos":54,"start":1734522761192,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522761819,"exec_count":27,"id":"38f172","input":"flat_reduction = Reduction(bias_subtract=True,\n                           dark_subtract=False,\n                           flat_correct=False,\n                           master_source=reduced_images,\n                           input_image_collection=images,\n                           destination=destination_folder,\n                           apply_to={'imagetyp':'flat field'})\nflat_reduction.action()","kernel":"python3","last":931,"pos":57,"start":1734522761203,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522762998,"exec_count":28,"id":"8736fa","input":"make_master_flat = Combiner(file_name_base='master_flat',\n                            group_by='filter',\n                            image_source=reduced_images,\n                            destination=destination_folder,\n                            apply_to={'imagetyp':'flat field'})\nmake_master_flat.action()","kernel":"python3","last":578,"pos":59,"start":1734522761832,"state":"done","type":"cell"}
{"cell_type":"code","end":1734522764532,"exec_count":29,"id":"3eaa2f","input":"# change the filename if necessary to match the name of your V band flat\nfilepath = os.path.join(destination_folder, \"master_flat_filter_B.fit\")\n\nmasterflat_im = fits.getdata(filepath)\n\n# What's the mean level in the dark image?\nprint('The masterflat has mean level of {:.1f} counts'.format(masterflat_im.mean() ))\n\n# display it\nfig, axis = plt.subplots(figsize=(9, 9))\naxis.set_title(\"Master flat (V filter)\")\n# custom scaling - see companion notebook\nvmin,vmax = np.percentile(masterflat_im, [1,99])\nimplot = axis.imshow(masterflat_im, cmap='viridis', origin='lower', vmin=vmin, vmax=vmax)\naxis.grid(False)\nplt.show()\nfig.savefig('master_flat.png')","kernel":"python3","last":981,"output":{"0":{"name":"stdout","text":"The masterflat has mean level of 23626.4 counts\n"},"1":{"data":{"image/png":"37278ffdbfbaddf5ccb3b347eb020284e848e7df","text/plain":"<Figure size 648x648 with 1 Axes>"},"metadata":{"image/png":{"height":384,"width":542},"needs_background":"light"}}},"pos":61,"start":1734522763008,"state":"done","type":"cell"}
{"cell_type":"code","id":"597d91","input":"","pos":39,"type":"cell"}
{"cell_type":"markdown","collapsed":true,"id":"7952a2","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-pencil\"></span>Make a master flat</h2>\n</div>\n</section>\n\n> This should be pretty similar to when we procude a master dark. Again, note the presence of ```group_by```. This allows us to produce one flat field per filter observed.","pos":58,"type":"cell"}
{"cell_type":"markdown","id":"0b8cfd","input":"Listing the contents of the ```destination_folder``` we should have several bias subtracted darks (dark_30_1.fit, etc) and master dark for each exposure time:","pos":49,"type":"cell"}
{"cell_type":"markdown","id":"19a417","input":"### Load the dataset into Python\n\nIn all the examples below, try and understand what is happening, but don't worry too much about understanding all the details of the code - the idea is to present you with a template you can use to reduce data in future...\n\n```ccdproc``` defines a type of object known as an ```ImageFileCollection``` which, once created has lots of nice ways to summarise the data and the contents of the FITS headers. To create one we require two arguments, the directory containing the data and a list of FITS header items we are interested in:","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"1ab326","input":"<section class=\"panel panel-info\">\n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-thumb-tack\"></span>  What FITS header items are important?</h2>\n</div>\n</section>\n\n> Notice the IMAGETYP entry in the table below. This is created from the IMAGETYP entry in the FITS header for each file. It labels each file as being a `Bias Frame`, `Dark Frame`, `Flat Field` or (for our science data) `Light frame`. These types of frames are discussed below, including a discussion of how they are taken, and what they are used for.\n\n> The ```reduction_tools``` code we imported above has to know which frames are which type and it is therefore crucial that the IMAGETYP entry is defined in the FITS header. Data you take on the 16-inch telescope should have this defined. However, sometimes there is no indication in the FITS header what kind of image the file contains. If this is the case for your data, the first step you may need to take is to **edit** the FITS header of your data files, following the instructions in the notebook `05b-editing_headers.ipynb`.","pos":31,"type":"cell"}
{"cell_type":"markdown","id":"24b3bc","input":"The average level should be a positive number of less than 50 counts, depending on the CCD temperature when your data was taken. What is the exposure time? We can read in the header of the dark frames to find out:","pos":53,"type":"cell"}
{"cell_type":"markdown","id":"24c95a","input":"So there's a mean dark current of <50 counts in a 300 second exposure. Note that not every pixel has the same value. Some of this is read noise, but it is also true that different pixels in a CCD show different levels of dark current. Some pixels show very high levels of dark current - these so called hot pixels can have a very serious effect on your photometry if your target star happens to lie on top of one!\n\n---\n\n## Flat Fields\n\nSuppose we use our telescope and CCD to take an image of a perfectly uniform light source. Would every pixel have the same number of counts in it? No - as we have seen each pixel will have a varying contribution from dark current and readout noise. What if we ignored these effects? The answer is still no. Various effects combine to mean that the count level can vary significantly across the image.\n\nBelow is an image of the twilight sky taken with the ROSA telescope on the roof of the Hicks building. On the small image scale of a telescope, the twilight sky is an excellent approximation to a uniformly illuminated light source. However, the image below is far from uniform.\n\n<img src=\"../../images/rosa_flat.png\" width=500></img>\n\nThere are three main reasons for the structure in this image:\n\n1. **Vignetting**\n\n    Consider the [design](http://slittlefair.staff.shef.ac.uk/teaching/phy241/lectures/L05/index.html#newtonian) of the Newtonian telescope. If the secondary mirror is exactly the right size to fit the beam produced by an on-axis source, some fraction of the beam produced by an off-axis source will miss the secondary mirror. This light will be lost, and off-axis sources will appear dimmer than on-axis sources. This is vignetting, and its effect is clearly visible in the figure above. \n\n2. **Pixel-to-Pixel variations**\n\n    Each pixel in a CCD is not exactly the same size; manufacturing tolerances mean that some pixels are larger than others. If each CCD pixel is exposed to a constant flux, the variation in pixel area means that some pixels will capture more photons than others. This effect can also be seen in the figure above if you look closely, and is often called flat field grain. \n\n3. **Dust grains on optical surfaces**\n\n    Dust grains on the window of the CCD, or on the filters will block out a small fraction of the light falling on the CCD. These grains appear as dark donuts, with the size of the donut depending on how far from the focal plane the dust grain is. Two such donuts are visible inthe figure above.\n    \n### Flat Field Frames\n\nIt is essential to correct our images for these effects. If we did not, the number of counts from an object would vary depending upon its location in the image, ruining our photometry. Fortunately, we can correct these effects using *flat field frames*. These are images taken of the twilight sky, which is assumed to be uniform (this is a good assumption for most instruments). Any variation in the flat field is therefore due to the effects above. Because vignetting and the contribution from dust grains can depend on the filter, flat fields must be taken in the same filters as your science data. \n\nFor small telescopes, it can be more convenient to use a specially constructed flat-field panel. These panels are carefully designed to provide a uniform light source. The advantage of a flat field panel over the twilight sky is that flat fields can be taken at any time, whereas twilight flats can only be taken in a narrow window after sunset. The 16\" Hicks telescope has a flat field panel for taking flat fields.\n\nHow should the flat field be used? First of all, we must realise that the flat field image must be **bias subtracted**. Dark frame subtraction is not normally necessary, since exposure times are short and the dark current will be very small. The count level of pixel $(i,j)$ in the bias-subtracted flat field image can be written as\n\n$$F_{ij} = \\alpha_{ij} F,$$\n\nwhere $F$ is the uniform flux of the twilight sky, or flat field panel. The quantity $\\alpha_{ij}$ represents the fraction of light lost to vignetting, pixel-to-pixel variations and dust grains. If we normalise our image, i.e. divide the flat field by the mean flux, $F$, we get an image whose brightness $f$ is given by $f_{ij}=\\alpha_{ij}$. Our science image is given by the product of the flux falling on each pixel $G_{ij}$, and the flat field effects, giving an image in which the brightness of pixel $(i,j)$ is given by \n\n$$ G'_{ij} = G_{ij}\\alpha_{ij}.$$\n\n**Dividing** our science image, $G'_{ij}$, by the normalised flat field image, $\\alpha_{ij}$, gives the actual flux falling on each pixel $G_{ij}$, as desired.\n\n### Calculating the master flat frame\n\nUsually we take several flat fields in each filter. These must all be bias subtracted and averaged together. The average frame produced must be normalised: divided by its mean.","pos":55,"type":"cell"}
{"cell_type":"markdown","id":"2593c6","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-question\"></span>  Q2: Stacking the calibrated files (4 points)</h2>\n</div>\n</section>\n\n> There will be many occasions when you will want to average several calibrated images of the same target. Usually you will want to perform photometry on a single image with an improved [signal-to-noise](http://slittlefair.staff.shef.ac.uk/teaching/phy241/lectures/L09/index.html) ratio.\n\n> This sounds like a daunting task. However, the key is (as always with Python) to look and see if someone has done it for you! In this case, there's the excellent [astroalign](https://github.com/toros-astro/astroalign) library, which aligns images by looking for matching patterns of stars. This is installed on CoCalc, but you'll need to install with `pip` if you're playing along at home.\n\n> `astroalign` provides a function that aligns an image with a reference image, and returns the aligned image. In the function definition below, I use this library to write my own function that takes a list of FITS filenames, aligns all the images, and returns a `numpy` array with the aligned image, and a FITS header you can use should you want to write the aligned image to a FITS file. \n\n> Have a look at the code below and make sure you understand in general what each line does. Marvel at how little code is needed to do something so complex!","metadata":{"deletable":false},"pos":67,"type":"cell"}
{"cell_type":"markdown","id":"29814c","input":"Having made a masterdark image - let's plot it:","pos":51,"type":"cell"}
{"cell_type":"markdown","id":"2e8545","input":"---\n\n## Header Data\n\nLet's take a look at the image header we read in earlier","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"2ea745","input":"Both B and V filter types show obvious signs that longer exposure times enables more background stars to be seen, there is also a noticeable difference between both the V and B 300 second images. The V\\_300 image shows a lot more background stars than the B\\_300 image, this implies that the stars are easier to image/observe using a filter in the 500\\-700 nm range and could imply that the stars contain less visible blue light and more visible red light\n\nLooking at the mean counts of V\\_300 against B\\_300 and V\\_30 against B\\_30 also shows that V\\_300 has a mean count of around 2.74 times that of B\\_300 and V\\_30 has a mean count of around 2.71 times that of B\\_30 \n","pos":83,"type":"cell"}
{"cell_type":"markdown","id":"36e5d6","input":"Now we can combine the copied files to make a master bias frame. First we must make a new ```ImageFileCollection``` to keep track of the files in the ```destination_folder```. Then we run the ```Combiner``` task.  Notice how the ```image_source``` argument is set to the ```ImageFileCollection``` we create? Also, note that the ```apply_to``` argument is again used to make sure we only combine BIAS files.\n\nWe can also set the name of the resulting file (in this case \"master_bias\") and set the combine method ('average' or 'median') and the destination directory. Run the code cell below to combine our three bias frames into a master bias.","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"3c40af","input":"With an ```ImageFileCollection``` created, we can get a look at what files are in the data dir as shown below. ","pos":29,"type":"cell"}
{"cell_type":"markdown","id":"3ea27e","input":"# Data Location\n\nBefore we get started, first we need to set two variables - the directory where the data is located, and the directory where we want to store the calibrated data. We are going to store the data you took for the observing project in a folder at the **top level** of the PHY241 project in the CoCalc. The full path to this folder will be `/home/user/PHY241/observing_project` and we are going to create two sub-folders within that main folder. One is called `raw_data` and will contain the data we took from the telescope. Another folder `calib_data` will contain the data after we have processed it in this notebook.\n\nThe code cell below will create those directories for us, if they don't exist, using the `os` Python module, which is useful for interacting with the computer operating system (OS).","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"48efbb","input":"We'll also need a FITS file to play with. We'll use the pleiades image from Session2\n\nFor most FITS files, particularly for simple images, we can get the header and the data from the file like so:","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"4cd6eb","input":"---\n\n## FITS images\n\nThe FITS (Flexible Image Transport System) file format is the most common data format for astronomical images and data. We need to know a little bit about it to deal with it.\n\n### HDUs\nA FITS file contains one or more Header/Data Units (HDUs). Each HDU contains a header, which contains some information about the file, and an optional data unit. For example, a FITS file containing a CCD image would have one HDU - the header would describe the data, and the data would be the CCD image itself.\n\n## Reading FITS images\n\nThe [astropy](http://www.astropy.org) library is a huge Python library with many, many useful goodies for astronomers to use. Amongst those is a library purely for reading and writing FITS files. We import it like so:\n\n","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"5b7624","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h1>Homework #5</h1>\n<h2><span class=\"fa fa-pencil\"></span>  Calibrating Science Frames</h2>\n</div>\n</section>\n\n> If you have run through the notebook above, you should have a collection of master frames in the ```destination_dir``` - a master bias, master darks for each exposure and a master flat field in each filter.\n\n> In the raw data directory you will also have exposures of your cluster with various filters and exposure times. Our task in this homework is to apply the master calibration frames to your data. As a reminder the steps we have to carry out on each image are:\n\n> 1. Subtract masterbias from image\n> 2. Subtract masterdark from image, correctly scaled for exposure times of image and dark\n> 3. Divide image by the masterflat for the correct filter\n> 4. Save calibrated images\n\n> The questions in the homework will guide you through this step by step.\n\n> Extra credit this week is 2 marks, which will be available for using functions in questions 2 and 3 so you do not repeat code over and over!","metadata":{"deletable":false},"pos":63,"type":"cell"}
{"cell_type":"markdown","id":"5c118e","input":"# Calibrating CCD data","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"5c6d36","input":"Notice how the flat field has a mean of ~25,000 counts. If we were doing this by hand we would normalise the flat field before using it. However, in this case, my ```Reduction``` object will take care of the normalisation when we use the flat field to correct our data. The structure due to vignetting, flat field grain and \"donuts\" from dust on the optical surfaces are clearly visible.\n\n## Using our calibration frames\n\nNow we have our master calibration frames, we can use them to calibrate our science CCD data! We will do this in the homework!\n\n---","pos":62,"type":"cell"}
{"cell_type":"markdown","id":"64c618","input":"We can use the same code we saw in the [plotting practical](http://nbviewer.ipython.org/github/StuartLittlefair/PHY241/blob/master/release/Session2/01_plotting.ipynb) to display the image data. If you find the representation and scaling of image data a bit confusing you may want to look at the companion notebook (`05a-imagescaling.ipynb`).","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"69e3e7","input":"<section class=\"objectives panel panel-warning\">\n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-certificate\"></span>Learning Objectives</h2>\n</div>\n</section>\n\n> * How to use the ```astropy``` library to read in FITS images\n> * How to display FITS images\n> * How to access FITS headers\n> * How to add, subtract divide and combine images\n> * Bias subtract, dark subtract and flat-field images","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"6c5ced","input":"---\n\n# An introduction to CCD Data processing\n\nBefore we can use CCD data for quantitative measurements, we have to perform some corrections to the data. This process is known as \"reducing\" the data.\n\n```ccdproc``` is a Python package which has been written to make reducing CCD data for astronomy simple. There is some documentation available [here](http://ccdproc.readthedocs.io/en/latest/). If you have selected the Anaconda (Python 3) kernel, then ccdproc will be available and installed.  \n\nIf you are running on the managed desktop or your own laptop, ```ccdproc``` and it's dependencies will not be installed. You need to start a terminal (linux, OS X), or an Anaconda command prompt (windows) and install ```ccdproc```. It is installed by typing ```pip install ccdproc```.\n\nWhilst ```ccdproc``` is a great package, using it directly can involve a lot of code just to keep track of which files are which, and to find the appropriate type of image to use for each step. To make life simpler, I have written some Python code you can re-use in your own project. The code is located in the file called ```reduction_tools.py``` which should be located in the same folder as this notebook - you can take a look at it if you like, but it's pretty advanced Python so don't worry if it makes little sense. \n\nThe code from this file can be imported like any other Python library, **provided it is in the same directory as the notebook you are running**. The code defines two Python objects, one for reducing CCD frames (called `Reducer`), the other for combining several frames (called `Combiner`).\n\nBelow we import the necessary modules, including the code I wrote:","pos":22,"type":"cell"}
{"cell_type":"markdown","id":"724a74","input":"---\n\n# Calibrating CCD Images\n\nOK, now we know how to read and write FITS files. Let's look at what calibrations we need to perform on CCD images - why we need to do them and how to do them in Python. The material in this section is **examinable**, so make sure you remember to revise this come exam time.\n\n## Bias Frames\n\nLet's recall how a CCD measures the number of electrons $N_e$ in each pixel. These electrons have a total charge $Q=eN_e$. We measure this charge by dumping it onto a capacitor with capacitance $C$ and measuring the voltage $V=Q/C$. We can re-write the number of electrons in terms of this tiny, analog voltage as\n\n$$ N_e = CV/e .$$\n\nIn other words, the voltage is proportional to the number of electrons. Because we need to store the data in digital format, the analog voltage is converted to a digital number of *counts* $N_c$, by an analog-to-digital converter (ADC). Since the value in counts is proportional to the voltage $N_c \\propto V$, it follows that the number of counts is proportional to the number of photo-electrons, i.e $N_e=GN_c$, where $G$ is the *gain*, measured in e-/ADU. The number of bits used by the ADC to store the count values limits the number of different count values that can be represented. For a 16-bit ADC, we can represent count values from 0 to 65,535.\n\nNow, imagine a relatively short exposure, taken from a dark astronomical site. Suppose that the gain, $G=1$ e-/ADU and that in our short exposure we create, on average, two photo-electrons from the sky in each pixel. Because of [readout noise](http://slittlefair.staff.shef.ac.uk/teaching/phy241/lectures/L08/index.html#readout), we will NOT have 2 counts in each pixel. Instead, the pixel values will follow a Gaussian distribution, with a mean of 2 counts, and a standard deviation given by the readout noise, which may be of the order of 3 counts. It should be obvious that this implies that many pixels should contain *negative count values*. However, **our ADC cannot represent numbers less than 0!** This means our data has been corrupted by the digitisation process. If we didn't fix this, it would cause all sorts of problems: in this case it would lead us to over-estimate the sky level.\n\nThe solution is to apply a *bias voltage*. This is a constant offset voltage applied to the capacitor before analog-to-digital conversion. The result is that, even if the pixel contains no photo-electrons, there is a voltage on the capacitor and the ADC returns a value of a few hundred counts, nicely solving the issue of negative counts. However, it does mean that we must correct for the bias level when doing photometry! Each pixel in our image contains counts from stars, from the sky background and from the bias level. We must **subtract the bias level** before performing photometry. \n\n### Measuring the bias level\n\nHow do we know what the bias level is? The easiest way to do this is to take a series of images with zero exposure time. Because there is no exposure time, these images contain no photo-electrons, and no thermally excited electrons. These images, known as *bias frames*, allow us to measure the bias level, and subtract it from our science data. Several bias frames are needed because the value of any pixel in a given bias frame will differ from the bias level due to readout noise. Averaging several frames together reduces the impact of readout noise and gives a more accurate estimate of the bias level. The *master bias frame* produced from this averaging can be subtracted from all science images to remove the bias level from each pixel.\n\n### Calculating the master bias frame\n\nThere are three bias frames in the ```data_folder```. The command below will simply perform some housekeeping on the headers of these files, and copy them to the ```destination_folder```. The ```input_image_collection``` argument sets the source of the images to be the ```ImageFileCollection``` we created above, whilst the ```destination``` argument sets where the files will be copied to. Also, take note that  the ```apply_to``` argument is used to select which type of files will be combined - in this case, only `Bias Frame` files will be copied. Finally, the ```copy_only``` argument means we only copy the files, and do not perform any further processsing:","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"79256c","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-question\"></span>  Q4: Discussion (2 points)</h2>\n</div>\n</section>\n\n> Using the information about CCD calibration you have read above, carefully inspect your images and below, discuss the differences between the calibrated and uncalibrated images.","metadata":{"deletable":false},"pos":82,"type":"cell"}
{"cell_type":"markdown","id":"7c0d4e","input":"","pos":85,"type":"cell"}
{"cell_type":"markdown","id":"887526","input":"You can see that the image header is typically used to store information about the image. The header can include information about the object, the exposure time, the filter used etc. All the items in the header follow a ```name = value``` pattern. The header can be accessed like a Python [dictionary](http://interactivepython.org/courselib/static/thinkcspy/Dictionaries/intro-Dictionaries.html). For simplicity, I've avoided discussing dictionaries in the course so far. However, they are **extremely** useful. Dictionaries are a bit like lists, but instead of accessing elements by index (e.g ```list[0]```) we can access them by name. \n\nThus, if we want the MJD-OBS item from the fits header we can access it like so:","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"8f5a75","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-pencil\"></span>Make a master dark</h2>\n</div>\n</section>\n\n> Using the code cell below, create and save a master dark frame. You shouldn't need to change any of the code. Notice that I've changed the combine method to `median` as discussed above.\n\n> Note the ```group_by``` argument in the ```Combiner```. The ```Combiner``` will make a master frame for each value of the FITS keyword listed in ```group_by```. By default this keyword is named exposure for darks, so if you have darks with exposure times of 10 sec, 15 sec and 120 sec you will get three master darks, one for each exposure time.","pos":47,"type":"cell"}
{"cell_type":"markdown","id":"8fe193","input":"---\n\n## Dark Frames\n\n[Recall](http://slittlefair.staff.shef.ac.uk/teaching/phy241/lectures/L08/index.html#semiconductors) that photo-electrons are produced in CCDs by photons exciting electrons from the valence band to the conduction band. However, this is not the only way to excite electrons into the conduction band. *Thermal excitation* is also capable of producing electrons in the conduction band. Thermal excitation of electrons is known as *dark current* and the electrons produced by it are indistinguishable from photo-electrons.\n\nDark current can be very substantial. At room temperature, the dark current of a standard CCD is typically 100,000 e-/pixel/s, which is sufficient to saturate most CCDs in only a few seconds! The solution is to cool the CCD. The typical operating temperatures of CCDs are in the range 150 to 263 K (i.e. -123 to -10$^{\\circ}$C). At major observatories, most CCDs are cooled to the bottom end of this range, generally using liquid nitrogen. The resulting dark current can be as low as a few electrons per pixel per hour. The CCDs on the Hicks telescopes are air-cooled to a few degrees below zero, and have dark currents of around 40 e-/pixel/hour. \n\nNeither of these values are negligible, especially for long exposures. Thus, every pixel in our image contains contributions from stars, sky background, bias level and dark current. The dark current must be measured, and subtracted from our science images for the same reasons as the bias level. For this purpose *dark frames* are taken. These are long exposures, taken with the shutter closed. These frames will have no contribution from photo-electrons, but they will contain dark current and the bias level. **This means that dark frames must have the bias subtracted from them before use.** Once the bias level has been subtracted off, several dark frames can be combined to make a *master dark frame*, which can be subtracted from your images. \n\nIt is best to combine the dark frames using the **median**, rather than the mean. Dark frames are often long exposures, which can be affected by cosmic rays. Cosmic rays hitting the CCD will excite also excite electrons. Taking the median of the master dark will help remove cosmic rays from the master dark frame.\n\nBecause the dark frame increases with time, it is easiest if the dark frames have the same exposure time as your science images. If they do not, it is possible to scale the dark frame by the ratio of exposure times, since dark current increases (roughly) linearly with time. Dark current is also a strong function of temperature - it is essential that dark frames are taken with the CCD at the same temperature as your science frame. \n\n### Calculating the master dark\n\nIn the raw data directory are three dark frames. Each one needs to be bias subtracted, and then combined with a median.","pos":44,"type":"cell"}
{"cell_type":"markdown","id":"91cff7","input":"###### The cell below loads the visual style of the notebook when run.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"9337ba","input":"## Writing FITS images\n\nSo, that's how you read image data from a FITS file. How do we write our own data?\n\nThe key to writing our own FITS files is to know that all FITS files must contain a Primary HDU - i.e the first HDU. We write a FITS file by creating a Primary HDU object, and using it's ```writeto``` method:","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"b3b302","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-question\"></span>  Q3: Plotting the stacked files (2 points)</h2>\n</div>\n</section>\n\n> Using the plotting code in this notebook and in Session 2, make a series of plots, each with two subplots; the raw frame on the LHS and the calibrated frame on the RHS. \n\n> Make one plot for each combination of filter and exposure.\n\n> Be sure to choose the image scaling carefully, so that details of the image background are visible, as well as the stars.\n\n","metadata":{"deletable":false},"pos":75,"type":"cell"}
{"cell_type":"markdown","id":"bb2b30","input":"# Uploading your observed data\n\nWe need to upload the data you observed for your project to cocalc, into the directory '/home/user/PHY241/observing_project/raw_data'. Using the ```Files``` tab in the top-left of ```CoCalc```, navigate to that directory and use the ```upload``` button (below), to upload the raw data you took, including image files, bias frames, dark frames and flat fields.\n\n<img style=\"margin: 20px\" src=\"../../images/upload_button.png\"/>","pos":26,"type":"cell"}
{"cell_type":"markdown","id":"c1158a","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-pencil\"></span>Read noise</h2>\n</div>\n</section>\n\n> Calculate the mean and standard deviation of the master bias, and a single bias frame. Note how averaging the bias frames has reduced the standard deviation around the mean level.\n\n> Now subtract the master bias array from the data array for a single bias. Has the std deviation gone down? Did subtracting a bias remove the readout noise? Do you know why not?","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"c24220","input":"> Use the function above to make combine your calibrated science images. You'll want to make one combined image for each combination of filter and exposure time, e.g one averaged image of all the 300s, V-band exposures and so on. **Hint:** look at the help for ```ImageFileCollection.files_filtered```, or use the ```glob``` module to make a list of the relevant files\n\n> Save your combined images as FITS files to the folder `/home/user/phy241/observing_project` with appropriate filenames.\n\n> Do the same for your raw, uncalibrated images. ","metadata":{"deletable":false},"pos":69,"type":"cell"}
{"cell_type":"markdown","id":"c29faf","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-pencil\"></span>Bias subtract the flat fields</h2>\n</div>\n</section>\n\n\n> In the data directory you should have a few twilight flat fields taken through the each filter.\n\n> You should be able to run the code cell below to bias subtract the flat fields:","pos":56,"type":"cell"}
{"cell_type":"markdown","id":"c70248","input":"If all that worked successfully, we will have created a master bias frame in our ```destination_folder```. Let's use the built-in ```os``` module to take a look!","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"cff81c","input":"The ```overwrite=True``` argument means that the file will be over-written if it already exists. Otherwise it will raise an exception. If we want to provide a header for the FITS file we can, but note that this is optional: ","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"d3ddab","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-question\"></span>  Q1: Calibrating the science files (2 points)</h2>\n</div>\n</section>\n\n> The ```Reduction``` code we used several times above can be used to calibrate all of our science frames:\n\n> There is some clever processing going on here being the scenes:\n\n> + If darks are subtracted, a dark of the same exposure time will be used, if available. If not, the dark with the closest exposure time will be scaled to match the science image.\n> + If the dark you want to scale appears not to be bias-subtracted an error will be raised.\n> + Flats are matched by filter.\n\n> Using the cells containing ```Reduction``` tasks above as a guide, write some code to bias subtract, dark subtract and flat-field correct the science (imagetyp = 'light frame') images in the raw directory. \n\n> If you are successful the final line will print the contents of your `destination_folder`, and you'll see calibrated versions of all of your science images.","metadata":{"deletable":false},"pos":65,"type":"cell"}
{"cell_type":"markdown","id":"e04e8a","input":"<div class=\"alert alert-info\">\n<h3><span class=\"fa fa-exclamation\"></span>  A Note on Kernels</h3>\n<p>We will be using some Python libraries, or modules, which are not available on all the Python kernels in CoCalc. <b>Make sure you select the Python 3 (system-wide) kernel from the Kernel menu in the notebook before proceeding</b></p>\n</div>","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"e3a229","input":"Now that we've made and saved our masterbias - let's take a look at it.","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"f4722c","input":"For more complicated FITS files, with many HDUs you might need to do something more advanced - for those cases look at the [documentation](http://astropy.readthedocs.org/en/stable/) for help!\n\n---\n\n## Image Data\n\nThe image_data is just a 2D numpy array, so we can use all the wonderful numpy [goodness](http://slittlefair.staff.shef.ac.uk/teaching/phy241/practicals/P03/index.html) with them:","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"fafcdf","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-pencil\"></span>Subtract bias from darks</h2>\n</div>\n</section>\n\n> Using the code cell below, subtract the bias from the darks. You should just be able to run the cell, but **read it carefully** and make sure\nyou can guess what each of the arguments do.\n\n> Note how the ```bias_subtract```, ```dark_subtract``` and ```flat_correct``` control which reduction steps are carried out. Also note that the ```master_source``` sets which collection of images will be searched for suitable master bias frames. The other arguments should be familiar now.","pos":45,"type":"cell"}
{"cell_type":"markdown","id":"fd277a","input":"As we have done before - let's plot a flat field image and look at the mean level.","pos":60,"type":"cell"}
{"cell_type":"markdown","id":"fdeff0","input":"In the [lectures](http://slittlefair.staff.shef.ac.uk/teaching/phy241/lectures/L06/index.html) we covered the basics of how CCDs work. Once we have a CCD image we'd like to use it for some scientific purpose. For example we might like to perform absolute photometry on the stars in the images.\n\nUsually, before doing that, we must perform some additional processing on the image. We'll look at why later in this practical. Before we do that, let's examine the file format that CCD images come in, and how to deal with it in Python.","pos":4,"type":"cell"}
{"id":"b2fe1f","input":"","pos":62.5,"type":"cell"}
{"id":0,"time":1734522670628,"type":"user"}
{"last_load":1733153261946,"type":"file"}