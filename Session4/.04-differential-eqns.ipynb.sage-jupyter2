{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-f6fa7edb-9d82-47fa-b1c8-d6134b62fa35.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_backend_state":1731849669429,"last_ipynb_save":1731856404908,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.9"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1731849669495,"exec_count":3,"id":"14b2ed","input":"from IPython.core.display import HTML\ncss_file = '../../styles/styles.css'\nHTML(open(css_file, \"r\").read())","kernel":"python3","last":62,"output":{"0":{"data":{"text/html":"<link href='http://fonts.googleapis.com/css?family=Crimson+Text' rel='stylesheet' type='text/css'>\n<link href='http://fonts.googleapis.com/css?family=Kameron' rel='stylesheet' type='text/css'>\n<link href='http://fonts.googleapis.com/css?family=Lato:200,300,400' rel='stylesheet' type='text/css'>\n<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'>\n<style>\n\n@font-face {\n    font-family: \"Computer Modern\";\n    src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunss.otf');\n}\n\n#notebook_panel { /* main background */\n    background: rgb(245,245,245);\n}\n\n\ndiv #notebook { /* centre the content */\n    background: #fff; /* white background for content */\n    margin: auto;\n    padding-left: 0em;\n}\n\n\n#notebook li { /* More space between bullet points */\n    margin-top:0.8em;\n}\n\n/* draw border around running cells */\ndiv.cell.border-box-sizing.code_cell.running { \n    border: 1px solid #111;\n}\n\n/* Put a solid color box around each cell and its output, visually linking them*/\ndiv.cell.code_cell {\n    background-color: rgb(256,256,256); \n    border-radius: 0px; \n    /* width: 105ex; */\n    padding: 0.5em;\n    margin-left:1em;\n    margin-top: 1em;\n}\n\ndiv.input_area {\n    border-color: rgba(0,0,0,0.10);\n    background: rbga(0,0,0,0.5);\n}\n\n/*\ndiv.text_cell {\n    max-width: 105ex; /* instead of 100%, */\n}\n*/\n\ndiv.text_cell_render {\n    font-family: \"Crimson Text\";\n    font-size: 12pt;\n    line-height: 145%; /* added for some line spacing of text. */\n}\n\ndiv.text_cell_render h1,\ndiv.text_cell_render h2,\ndiv.text_cell_render h3,\ndiv.text_cell_render h4,\ndiv.text_cell_render h5,\ndiv.text_cell_render h6 {\n    font-family: 'Kameron';\n    font-weight: 300;\n}\n\ndiv.text_cell_render h1 {\n    font-size: 24pt;\n}\n\ndiv.text_cell_render h2 {\n    font-size: 18pt;\n}\n\ndiv.text_cell_render h3 {\n    font-size: 14pt;\n}\n\n.rendered_html pre,\n.rendered_html code {\n    font-size: medium;\n    background-color: rgba(246,246,246,1);\n    padding: 2px;\n}\n\n.rendered_html ol {\n    list-style:decimal;\n    margin: 1em 2em;\n}\n\n.CodeMirror pre{\n        font-family: 'Source Code Pro', Consolas, monocco, monospace;\n}\n\n/* Make space between the fa icon and the rest of the header */\n.panel-heading h1 span,\n.panel-heading h2 span,\n.panel-heading h3 span,\n.panel-heading h4 span,\n.panel-heading h5 span,\n.panel-heading h6 span {\n    padding-right: 10px;\n}\n\n.fa {\n    padding: 5px;\n    }\n   \nkbd {\n    padding:0.1em 0.6em;\n    border:1px solid #ccc;\n    font-size:11px;\n    font-family:Arial,Helvetica,sans-serif;\n    background-color:#f7f7f7;\n    color:#333;\n    -moz-box-shadow:0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;\n    -webkit-box-shadow:0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;\n    box-shadow:0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;\n    -moz-border-radius:3px;\n    -webkit-border-radius:3px;\n    border-radius:3px;\n    display:inline-block;\n    margin:0 0.1em;\n    text-shadow:0 1px 0 #fff;\n    line-height:1.4;\n    white-space:nowrap;\n}\n\n</style>\n<script>\n    MathJax.Hub.Config({\n                        TeX: {\n                           extensions: [\"AMSmath.js\"],\n                           equationNumbers: { autoNumber: \"AMS\", useLabelIds: true}\n                           },\n                tex2jax: {\n                    inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n                    displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ]\n                },\n                displayAlign: 'center', // Change this to 'center' to center equations.\n                \"HTML-CSS\": {\n                    styles: {'.MathJax_Display': {\"margin\": 4}}\n                }\n        });\n</script>","text/plain":"<IPython.core.display.HTML object>"},"exec_count":3}},"pos":1,"start":1731849669454,"state":"done","type":"cell"}
{"cell_type":"code","end":1731849672148,"exec_count":4,"id":"b816fe","input":"# initial conditions\ny   = 78.0  # height of the art's tower, in metres\nvy  = 0.0  # starting at rest\ntau = 0.01 # timestep of 0.01 seconds\ng   = 9.8 # acceleration due to gravity!","kernel":"python3","last":5,"pos":6,"start":1731849672141,"state":"done","type":"cell"}
{"cell_type":"code","end":1731849675152,"exec_count":5,"id":"c1f91e","input":"# calculate the values at the next timestep\nvy_next = vy - g*tau\ny_next  = y + vy*tau\n\n# update the current values to be the new ones\nvy = vy_next\ny  = y_next","kernel":"python3","last":2,"pos":8,"start":1731849675146,"state":"done","type":"cell"}
{"cell_type":"code","end":1731849676201,"exec_count":6,"id":"4ef221","input":"# create empty lists to store the height and time\ny_values = []\nt_values = []\n\n# create a variable to store current time\nt_now = tau\n\n# loop until y=0 (we hit the ground!)\nwhile (y >= 0):\n    # update our time variable\n    t_now = t_now + tau\n\n    # calculate values after small timestep\n    vy_next = vy - g*tau\n    y_next  = y + vy*tau\n\n    # update the old values to be the new ones\n    vy = vy_next\n    y  = y_next\n\n    # store these values in lists\n    y_values.append(y)\n    t_values.append(t_now)\n\n# loop is over. we'll convert our Python lists to NumPy arrays\n# This makes numerical calculations easier...\nimport numpy as np\ny_values = np.array(y_values)\nt_values = np.array(t_values)\n","kernel":"python3","last":3,"pos":10,"start":1731849676194,"state":"done","type":"cell"}
{"cell_type":"code","end":1731849678312,"exec_count":7,"id":"d40a1d","input":"# matplotlib import\n%matplotlib inline\nimport matplotlib.pyplot as plt\n\n\ndef fall(t_values, initial_height=78.0):\n    \"\"\"Calculate the height of an object falling from rest\n\n       Use the analytical formula y = y0 + 0.5*a*t**2 to\n       calculate the height of an object falling from rest\n       as a function of time.\n\n       Args:\n           t_values (array): an array of time values at which to calculate height\n           initial_height (float): an optional initial height. Default is 78m\n    \"\"\"\n    # REPLACE \"1.0\" BELOW WITH THE CORRECT FORMULA TO RETURN HEIGHT\n    # hint: t_values is a numpy array, so there is no need to use a for loop\n    return initial_height + (0.5*-g*t_values**2)\n# use the function above to calculate values\ny_formula = fall(t_values)\n\n# plot the two and compare\nfig, axis = plt.subplots(figsize=(9,5))\n\n# plot numerical solution with thin line\naxis.plot(t_values,y_values,label='numerical',lw=1)\n\n# plot the analytical solution with a thick dashed line\naxis.plot(t_values,y_formula,ls='--',lw=3,label='analytical')\n\n# draw a legend\naxis.legend()\n\n# label axes and show\naxis.set_xlabel('Time (seconds)')\naxis.set_ylabel('Height (meters)')\nplt.show()","kernel":"python3","last":1588,"output":{"0":{"data":{"image/png":"d3264bd0f713129354cdc4e51b1b63fe622ea2dd","text/plain":"<Figure size 648x360 with 1 Axes>"},"metadata":{"image/png":{"height":316,"width":549},"needs_background":"light"}}},"pos":12,"start":1731849677534,"state":"done","type":"cell"}
{"cell_type":"code","end":1731849683507,"exec_count":8,"id":"1a348e","input":"import time\n### INITIAL CONDITIONS\n# initial displacement, theta\ntheta = np.radians(10) # 10 degrees in radians - remember, np.sin needs an angle in radians\nomega = 0.0 # omega=0 (start at rest)\ntau = 0.1 # timestep of 0.1s\nt_now = 0.0 # start at t=0s\n\nl = 10.0 # length of pendulum in m\ng = 9.8  # gravity\n\n# we will use lists to store our result at each timestep.\n# Initialise with starting values\ntheta_values = [theta]\nomega_values = [omega]\nt_values = [t_now]\n\nstart = time.time()\n# solve motions for 35s\nwhile t_now < 35:\n\n    # time after timestep\n    t_now = t_now + tau\n\n    # calculate values after timestep\n    theta_new = theta + omega*tau\n    omega_new = omega - g * np.sin(theta) * tau / l\n\n    # update current values\n    theta = theta_new\n    omega = omega_new\n\n    # store in lists\n    theta_values.append(theta)\n    t_values.append(t_now)\n    omega_values.append(omega)\n\n# finished loop\nend = time.time()\nprint(f\"took {end-start} seconds\")\n\n# convert lists to arrays\nt_values = np.array(t_values)\ntheta_values = np.array(theta_values)\nomega_values = np.array(omega_values)\n\n# Calculate Energy per unit mass\nEnergy_per_unit_mass = 0.5*l**2*omega_values**2 + g*l*(1 - np.cos(theta_values)) # Use below equation\n\n# convert theta back to degrees\ntheta_values = np.degrees(theta_values)\n\n# plot!\nfig, axis1 = plt.subplots( figsize=(9,5),nrows=2,ncols=1)\naxis1[0].plot(t_values,theta_values)\naxis1[1].plot(t_values, Energy_per_unit_mass)\n# label axes and show\naxis1[1].set_xlabel('Time (seconds)')\naxis1[0].set_ylabel('Angle (degrees)')\naxis1[1].set_ylabel('Energy per unit mass')\n\naxis1[0].axis('tight')\nplt.show()","kernel":"python3","last":638,"output":{"0":{"name":"stdout","text":"took 0.0011131763458251953 seconds\n"},"1":{"data":{"image/png":"9632eb94133cbf28eb465054a24a7a5f9cab802e","text/plain":"<Figure size 648x360 with 2 Axes>"},"metadata":{"image/png":{"height":316,"width":558},"needs_background":"light"}}},"pos":14,"start":1731849682953,"state":"done","type":"cell"}
{"cell_type":"code","end":1731849689570,"exec_count":9,"id":"20f0fc","input":"from scipy.integrate import odeint\n\n### INITIAL CONDITIONS\n# initial displacement, theta\ntheta = np.radians(10) # 10 degrees in radians - remember, np.sin needs an angle in radians\nomega = 0.0 # omega=0 (start at rest)\n\nl = 10.0 # length of pendulum\ng = 9.8  # gravity.\n\n# intial state vector - \nX0 = [theta, omega]\n\n# define an array of times to calculate solution for\n# We will go from 0 to 35s, with a timestep of 0.1s\nt = np.arange(0.0, 35.0, 0.1)\nprint (\"Solving pendulum at {} times\".format(len(t)))\n\n\"\"\"\nThe first argument for odeint is a function that calculates f = dX/dt.\n\nThis function in turn has two arguments. The first is the \"state\" of the system  - the vector X.\nThe second is the time. We don't use it in this case, but our function definition\nhas to follow the form expected by odeint.\n\nWe have to write this function ourselves, which I do below.\n\"\"\"\ndef f_func(state, time):\n    # state list is [theta, omega]\n    # unpack into named variables\n    # THINK! - are these the same omega, theta as above (global/local)?\n    theta, omega = state\n    # function should return dX/dt\n    return [omega, -g*np.sin(theta)/l]\n\n#Solving these equations is as simple as calling odeint!\nX = odeint(f_func, X0, t)\n\nprint (\"Shape of X is {}\".format(X.shape))\n# X is a 2D array.\n# each row is the state vector [theta, omega] at a given time\n# each column is how that component changes with time\ntheta = X[:, 0]\nomega = X[:, 1]\n\n# convert theta back to degrees from radians\ntheta = np.degrees(theta)\n\n# plot!\nfig, axis = plt.subplots(figsize=(9,5))\naxis.plot(t,theta)\n# label axes and show\naxis.set_xlabel('Time (seconds)')\naxis.set_ylabel('Angle (degrees)')\naxis.axis('tight')\nplt.show()","kernel":"python3","last":2076,"output":{"0":{"name":"stdout","text":"Solving pendulum at 350 times\nShape of X is (350, 2)\n"},"1":{"data":{"image/png":"96997a18eb356b25ab31e3f4c7b2d536d18e47d3","text/plain":"<Figure size 648x360 with 1 Axes>"},"metadata":{"image/png":{"height":316,"width":567},"needs_background":"light"}}},"pos":19,"start":1731849687188,"state":"done","type":"cell"}
{"cell_type":"code","end":1731849827157,"exec_count":12,"id":"84d0d9","input":"def f_func(state, time, cd, mass, rho, A):\n    \"\"\"Calculate the differential of state vector as a function of time\n\n    Args:\n        state (list): the state vector at time t\n        time (float): the time t\n        cd (float): the dimensionless drag coefficient\n        mass (float): mass of the object in kg\n        rho (float): density of air (kg/m3)\n        A (float): cross-sectional area of object (kg)\n\n    Returns:\n        (list): the differential of the state vector at time t\n    \"\"\"\n    # defensive program - check shape of state vector\n    assert len(state)==2, \"Expected length 2 state vector\"\n    vy,y = state\n    # WRITE YOUR CODE HERE\n    return [-g+(0.5*cd*rho*A*(vy**2)/mass), vy] # Take equation from above and divide by mass","kernel":"python3","last":4,"metadata":{"deletable":false},"pos":22,"start":1731849827153,"state":"done","type":"cell"}
{"cell_type":"code","end":1731849868603,"exec_count":13,"id":"e7afc2","input":"from nose.tools import assert_equal, assert_almost_equal\na,vy = f_func([0.,78.],0.0,0.5,1,1.2,1)\nassert_almost_equal(a, -9.8)\nassert_almost_equal(vy, 0.0)\na,vy = f_func([-2.,78.],0.0,0.5,1,1.2,1)\nassert_almost_equal(a,-8.6)\nassert_almost_equal(vy,-2)\na,vy = f_func([2.,78.],0.0,0.5,2,1.2,1)\nassert_almost_equal(a,-9.2)\nassert_almost_equal(vy,2)","kernel":"python3","last":82,"metadata":{"deletable":false},"pos":23,"start":1731849868598,"state":"done","type":"cell"}
{"cell_type":"code","end":1731850059759,"exec_count":14,"id":"28212b","input":"# initial conditions\ny   = 78.0  # Height of the art's tower, in metres\nvy  =  0.0  # Starting at rest\nrho = 1.2 # Density of air [kg /m^3]\nmass = 0.45 # Mass of football [kg]\nA = 0.38 # Cross sectional area of football [m^2]\ncd = 0.5 # Drag coefficient \n\n# array of times for the solution\n# from 0-15 seconds with timestep of 0.01s\nt = np.arange(0.0, 15.0, 0.01)\n\n# initial state vector\nX0 = [vy, y]\n\n# WRITE YOUR CODE HERE\nX = odeint(f_func, X0, t, args=(cd, mass, rho, A))\n\ny = X[:,1]\n\n# plot!\nfig, axis = plt.subplots(figsize=(9, 5))\naxis.plot(t,y)\n# label axes and show\naxis.set_xlabel('Time (seconds)')\naxis.set_ylabel('Height (meters))')\naxis.set_ylim((0, 78))\nplt.show()","kernel":"python3","metadata":{"deletable":false},"output":{"0":{"data":{"image/png":"d7adbce33fcf820659d466577b8ba10819c53f4a","text/plain":"<Figure size 648x360 with 1 Axes>"},"metadata":{"image/png":{"height":316,"width":549},"needs_background":"light"}}},"pos":25,"start":1731850059468,"state":"done","type":"cell"}
{"cell_type":"code","end":1731850062600,"exec_count":15,"id":"5ce270","input":"assert_almost_equal(y[0], 78)\nassert_almost_equal(y[-1], -12.496644246)\nassert_equal(len(y), 1500)\nassert_equal(len(y.shape), 1)","kernel":"python3","last":8,"metadata":{"deletable":false},"pos":26,"start":1731850062595,"state":"done","type":"cell"}
{"cell_type":"code","end":1731851111652,"exec_count":31,"id":"f507bf","input":"vy_terminal = -np.sqrt((2 * mass * g)/(rho * A * cd))  # Velocity is in negative vertical direciton, hence negative velocty \nprint(f\"terminal velocity is {vy_terminal} m/s\")","kernel":"python3","last":4,"metadata":{"deletable":false},"output":{"0":{"name":"stdout","text":"terminal velocity is -6.219663216470471 m/s\n"}},"pos":28,"start":1731851111645,"state":"done","type":"cell"}
{"cell_type":"code","end":1731851112890,"exec_count":32,"id":"42b585","input":"assert_almost_equal(vy_terminal, -6.21966321668)","kernel":"python3","last":2,"metadata":{"deletable":false},"pos":29,"start":1731851112885,"state":"done","type":"cell"}
{"cell_type":"code","end":1731855713809,"exec_count":59,"id":"2a5b27","input":"from scipy.interpolate import interp1d\n\n\n# initial conditions\ny   = 78.0  # Height of the art's tower, in metres\nvy  =  0.0  # Starting at rest\nrho = 1.2 # Density of air [kg /m^3]\nfootball_mass = 0.45 # Mass of football [kg]\nfootball_A = 0.38 # Cross sectional area of football [m^2]\ngolfball_mass = 0.045 # Mass of golf ball [kg]\ngolfball_A = 1.43e-3 # Cross sectional area of golf ball [m^2]\nbeachball_mass = 0.1 # Mass of Beach ball [kg]\nbeachball_A = np.pi # Cross sectional area of Beach ball [m^2]\ncd = 0.5 # Drag coefficient \n\n# array of times for the solution\n# from 0-90 seconds with timestep of 0.01s\n#t = np.arange(0.0, 15.0, 0.01)\nt = np.arange(0.0, 90, 0.01)\n\n# initial state vector\nX0 = [vy, y]\n\n# WRITE YOUR CODE HERE\nX_football = odeint(f_func, X0, t, args=(cd, football_mass, rho, football_A))\nX_golfball = odeint(f_func, X0, t, args=(cd, golfball_mass, rho, golfball_A))\nX_beachball = odeint(f_func, X0, t, args=(cd, beachball_mass, rho, beachball_A))\n\n\ny_football = X_football[:,1]\ny_golfball = X_golfball[:,1]\ny_beachball = X_beachball[:,1]\n\n# plot!\nfig, axis = plt.subplots(figsize=(9, 5))\naxis.plot(t,y_football, label=\"Football\")\naxis.plot(t,y_golfball, label=\"Golf ball\")\naxis.plot(t,y_beachball, label=\"Beach ball\")\n\n# label axes and show\naxis.set_xlabel('Time (seconds)')\naxis.set_ylabel('Height (meters))')\naxis.set_xlim(0,80)\naxis.set_ylim((0, 78))\n\n\naxis.legend()\n\nplt.show()\n\n\n#Time calculations\ngolfball_interp = interp1d(y_golfball, t)\nfootball_interp = interp1d(y_football, t)\nbeachball_interp = interp1d(y_beachball, t)\n\nT_golfball = golfball_interp(0) #Time taken for golf ball to reach the ground \nT_football = football_interp(0) #Time taken for football to reach the ground\nT_beachball = beachball_interp(0) #Time taken for beach ball to reach the ground\n\n\nprint(f\"golfball takes {T_golfball:.3f} seconds to reach the ground\")\nprint(f\"Football takes {T_football:.2f} seconds to reach the ground\")\nprint(f\"Beach ball  takes {T_beachball:.2f} seconds to reach the ground\")","kernel":"python3","metadata":{"deletable":false},"output":{"0":{"data":{"image/png":"a7ea1349f6eb0613f351941c091dc47470ba4a4f","text/plain":"<Figure size 648x360 with 1 Axes>"},"metadata":{"image/png":{"height":316,"width":556},"needs_background":"light"}},"1":{"name":"stdout","text":"golfball takes 4.498 seconds to reach the ground\nFootball takes 12.98 seconds to reach the ground\nBeach ball  takes 76.56 seconds to reach the ground\n"}},"pos":31,"start":1731855713427,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1b26cc","input":"<section class=\"objectives panel panel-warning\">\n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-certificate\"></span>Learning Objectives</h2>\n</div>\n</section>\n\n> * Learn how to solve ordinary differential equations using both Euler's Method and SciPy","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"21afae","input":"## How to solve ODEs numerically.\n\nThe simple and intuitive way to solve an ODE is to use what is known as Euler's Method. To see how this works, let's consider the formal definition of $\\frac{dy}{dt}$:\n\n$$\\frac{dy}{dt} = \\lim_{\\tau\\to0} \\, \\frac{y(t+\\tau) - y(t)}{\\tau}$$\n\nIf we wanted to estimate $\\frac{dy}{dt}$ on a computer, we could use some very small, but finite value of $\\tau$:\n\n$$\\frac{dy}{dt} \\approx \\frac{y(t+\\tau) - y(t)}{\\tau}.$$\n\nWe can re-arrange this equation, and note that $\\frac{dy}{dt} = v_y$, to get\n\n$$y(t+\\tau) \\approx y(t) + v_y \\tau.$$\n\nWe can find $v_y(t+\\tau)$ using the same method with the equation $\\frac{dv_y}{dt} = -g$:\n\n$$v_y(t+\\tau) \\approx  v_y(t) - g\\tau.$$\n\nWith a bit of thought, this suggests an iterative method for finding both $v_y(t)$ and $y(t)$. Starting with some known conditions at $t=0$, we can compute the velocity a small time later, $v_y(\\tau)$, using the equation above. We can then use this to find $y(\\tau)$. Now, we can use these values and repeat the process to find $v_y$ and $y$ for the next time step, and so on for as long as we desire. This is Euler's Method.\n\nBelow, we'll look at a concrete (hah!) example and solve the equation for an object falling from the roof of the Arts Tower. First, we'll define our initial conditions, and choose a small timestep, $\\tau$.","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"4116e2","input":"We can see that Euler's method worked. However, it was totally uneccessary, since there's an analytical solution in this case. Let's look at another example that **can't** be solved analytically - the simple pendulum.\n\n## Example 2: The Simple Pendulum\n\nA simple pendulum of length $l$ is described by the differential equation\n\n$$\\frac{d^2\\theta}{dt^2} = -\\frac{g}{l} \\sin \\theta,$$\n\nwhere $\\theta(t)$ is the angular displacement as a function of time. To solve this numerically the first step is, once again, to convert this second order equation into two coupled first order equations:\n\n\n$$\n\\frac{d\\theta}{dt} = \\omega(t) \n$$\n$$\n\\frac{d\\omega}{dt} = -\\frac{g}{l}\\sin \\theta.\n$$\n\nThe corresponding Euler equations are:\n\n$$\\omega_{n+1} = \\omega_n- \\frac{g}{l} \\sin( \\theta_n ) \\tau$$\n$$\\theta_{n+1} = \\theta_n + \\omega_n \\tau.$$\n\nThe code below solves the simple pendulum equation using Euler's method. I've started the pendulum from rest with an initial displacement of 10$^{\\circ}$. The pendulum is a nice long 10m. **Again, read the code and the comments carefully to make sure you understand**.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"442e7a","input":"## Truncation Error\n\nClearly the code for the pendulum above is incorrect at some level since the results violate the law of energy conservation! The reason for the behaviour above is the approximation we made in using a finite timestep. The equation we used\n\n$$\\frac{dy}{dt} \\approx \\frac{y(t+\\tau) - y(t)}{\\tau},$$\n\nis only an approximation to the true differential, and the approximation gets worse as the timestep gets larger. You may well remember this fact from the orbit calculation lab you did in the first year. \n\nOne solution is to use a finer timestep, which makes the approximation better. This is at the expense of computation time. The other solution is to use a more sophisticated method than Euler's method.\n\nScipy has a sophisticated and more accurate solver for ordinary differential equations (ODEs) called **Isoda**. In the homeworks we will see how to use Scipy's ODE solver.\n\n---------\n<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h1>Homework #4</h1>\n<h2><span class=\"fa fa-pencil\"></span>Solving ODEs with SciPy</h2>\n</div>\n</section>\n\nSciPy's ODE solvers are found in the ```scipy.integrate``` package. There are two functions of interest in that package. ```odeint``` is the simplest, whilst ```ode``` is more flexible. The two are quite similar in use, so we'll focus on the simpler of the two, ```odeint``` here.\n\nThe difference between SciPy's ODE solvers and the Euler method we coded by hand above is that SciPy uses clever computer algorithms to be more accurate with the same timestep. This saves computing time and allows more difficult problems to be solved. We won't concern ourselves with the details of these algorithms - we'll just look at using them like a \"black box\".\n\nThe key with using SciPy is to remember that ODEs are ones that can be written in the form\n\n$$\n\\frac{d{\\mathbf X}}{dt} = {\\mathbf f}({\\mathbf X}, t),\n$$\n\nwhere the bold typeface indicates a vector. Looking again at the equation describing the motion of a pendulum of length $l$\n\n$$\\frac{d^2\\theta}{dt^2} = -\\frac{g}{l} \\sin \\theta,$$\n\nwhere $\\theta(t)$ is the angular displacement as a function of time. Again, it's not obvious that this can be reduced to the form above. As we saw earlier though, we can write this as two coupled equations:\n\n$$\\begin{align*}\n\\frac{d\\theta}{dt} &= \\omega(t) \\\\\n\\frac{d\\omega}{dt} &= -\\frac{g}{l}\\sin \\theta.\n\\end{align*}\n$$\n\nThis can be written in the initial vector form if the vector ${\\mathbf X}$ is set to\n\n$$\n{\\mathbf X} = \\begin{bmatrix}\\theta \\\\ \\omega \\end{bmatrix}\n$$\n\nWith ${\\mathbf X}$ defined, we can see that it's differential is \n\n$$\n{\\mathbf f}({\\mathbf X}, t) = \\frac{d{\\mathbf X}}{dt} = \\begin{bmatrix}\\omega \\\\ -\\frac{g}{l}\\sin \\theta \\end{bmatrix}\n$$","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"58f514","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-question\"></span>Q1: Adding air resistance (4 points)</h2>\n</div>\n</section>\n\n> For an object of mass $m$ falling straight down against air resistance, the differential equation is\n\n> $$m \\frac{d^2y}{dt^2} = -mg + \\frac{1}{2} C_d \\rho A v_y^2,$$\n\n> The second term on the RHS is the drag force, where $\\rho$ is the density of air, $A$ is the cross-sectional area of the object and $C_d$ is the drag coefficient. The drag coefficient is dimensionless and depends on the shape of object. For a smooth spherical object falling reasonably fast, $Cd \\approx 0.5$.\n\n> Using this equation, complete the code below to define a function that calculates ${\\mathbf f}({\\mathbf X}, t) = \\frac{d{\\mathbf X}}{dt}$.\n\n> *Hint: a good choice of ${\\mathbf X}$ in this case is *\n\n> $$\n{\\mathbf X} = \\begin{bmatrix}v_y \\\\ y \\end{bmatrix}\n$$\n\n> **Remember, your homework will be marked in part based on whether it passes the tests after each question. Make sure your code passes these tests!**","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"5ff69a","input":"Now we'll increment a single timestep, just to see how it's done...","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"6b88e5","input":"# Solving Differential Equations","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"6fd4a2","input":"Terminal velcoity equation is as follows:\n\n$ V_{t} = \\sqrt{\\frac{2*m*g}{\\rho*A*C_{d}}} $  \n\nInputting mass, gravity, density, Drag coefficient and Cross sectional area values yields a value for terminal velocity","pos":27.5,"type":"cell"}
{"cell_type":"markdown","id":"74e6c6","input":"If we wanted to keep going we could put the code above in a loop. However, if we want to plot $y$ against $t$ we'll need to store all the values we calculate as we go along. *Read the code below carefully and pay close attention to the comments*! It creates some empty lists to store $y$ and $t$, and loops until our object hits the ground ($y=0$), filling the lists as we go:","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"841b2e","input":"<div class=\"alert alert-info\">\n<h4>\nAs a not-so-subtle hint, the material in this lecture may come in handy when you need to solve the Lane-Emden equations of stellar structure in the PHY213 Labs!</h4>\n</div>\n\n\n## Ordinary Differential Equations\n\nOrdinary differential equations are ones that can be written in the form\n\n$$\n\\frac{d{\\mathbf X}}{dt} = {\\mathbf f}({\\mathbf X}, t),\n$$\n\nwhere the bold typeface indicates a vector. \n\nA simple example is an object falling straight down under gravity. This object obeys the second-order differential equation\n\n$$\\frac{d^2y}{dt^2} = -g.$$\n\nThis doesn't look like the equation above for an ordinary differential equation. However, we can break this into two, coupled, equations:\n\n$$\n\\begin{align*}\n\\frac{dy}{dt} &= v_y \\\\ \n\\frac{d v_y}{dt} &= -g.\n\\end{align*}\n$$\n\nThis can be written in the above vector form if\n\n$$\n{\\mathbf X} = \\begin{bmatrix}y \\\\ v_y \\end{bmatrix}\n$$\n\nand \n\n$$\n{\\mathbf f}({\\mathbf X}, t) = \\frac{d{\\mathbf X}}{dt} = \\begin{bmatrix}v_y \\\\ -g \\end{bmatrix}\n$$\n\nOf course, this very simple example doesn't need a computer to solve it! The analytical solution is $y = ut + \\frac{1}{2}at^2$. However - we're going to use it as our example for how to solve a differential equation with a computer anyway. For one thing, we can easily check our answer, but we can also solve more difficult ODEs once we understand the method.\n\n---","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"84fe6e","input":"###### The cell below loads the visual style of the notebook when run.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"8bb164","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-question\"></span>Q2: Solving the equation (4 points)</h2>\n</div>\n</section>\n\n> Use your equation and ```odeint``` to calculate how a football would fall from the Art's tower. The tower is 78m high. The density of air is roughly 1.2 kg m$^{-3}$. A football weighs roughly 0.45 kg and has a cross sectional area of 0.38 m$^2$.\n\n> Store the solution for the height of the ball in an array called ```y```. Plot $y$ against $t$ to make sure your solution makes sense.\n\n> *Hint: the definition of your ```f_func``` function differs from the simple one we used in class. You will need to use the ```args``` optional argument of ```odeint``` to pass the extra arguments to your function* The ```args``` optional argument for ```odeint``` works in exactly the same way as it did for the integration function ```quad``` we used last week.","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"9bbd40","input":"Fantastic! It works very well - even though the timestep of 0.1s gave an innacurate solution using Euler's method, the same timestep gives what looks like accurate behaviour using the Isoda algorithm used by ```odeint```. Now you've seen an example, your homework is to re-visit our first example of an object falling under gravity, but to add air resistance!","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"b593a8","input":"<section class=\"panel panel-warning\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-question\"></span>Extra Credit (3 points)</h2>\n</div>\n</section>\n\n> Extra credit questions allow you to make up for marks dropped in this and other homeworks. You can't score more than 100% overall, but if you get 3 extra credit points this week, and lose 3 points next week, you'd still be on course for 100% marks. I don't expect you to answer extra credit questions, *unless you want to*.\n\n> For extra credit this week, use odeint to plot $y$ vs $t$ for a football, a beach-ball and a golf ball falling from the Arts Tower. Correctly label your plot so you know which is which.\n\n> Calculate the length of time each ball takes to hit the ground.\n\n> A golf ball weighs 45g and has a cross-sectional area of $1.43 \\times 10^{-3}$ m$^2$. A beach ball weighs 100g and has a cross-sectional area of $\\pi$ m$^2$.","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"bfe4af","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-pencil\"></span>Checking our work</h2>\n</div>\n</section>\n\n> So we're done - but how do we know if it worked? What we should do is plot $y$ vs $t$ and see how our numerically calculated answer compares to the true solution for an object dropped from rest $y = y_0 + \\frac{1}{2} at^2$. \n\n> Complete the code cell below to produce this plot. \n","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"d818c3","input":"### The plot improves with smaller time steps, the time take to run the code cell significantly increases with smaller time steps\n\n","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"dc449c","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-pencil\"></span>A matter of energy</h2>\n</div>\n</section>\n\n> Looking at the plot above, something is clearly going wrong! A pendulum shouldn't describe larger oscillations as time goes by without being forced. We can get a handle on what is going on by seeing what is happening to the pendulum's ernergy!\n\n> Modify the code above$^1$ to add a subplot of the energy per unit mass of the pendulum as a function of time. The total energy per unit mass of a pendulum can be written as\n\n> $$E/m = \\frac{1}{2} l^2 \\omega^2 + gl (1-\\cos\\theta).$$\n\n> Run the resulting code for time steps of 0.1, 0.01 and 0.001 seconds. By what fraction does the energy change given these three time steps? Did the result improve with smaller time steps? Did the program take significantly longer for the smaller time steps?\n\n> Write your answers to these question in the markdown cell below.\n\n> $^1$ it's a good idea to duplicate the original code cell and make changes in the duplicate","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"ecaa42","input":"<section class=\"challenge panel panel-success\"> \n<div class=\"panel-heading\">\n<h2><span class=\"fa fa-question\"></span>Q3: Terminal Velocity (2 points)</h2>\n</div>\n</section>\n\n> After a few seconds, your graph of $y$ vs $t$ should be linear. This is because the football has reached *terminal velocity*. In the code cell below, calculate the terminal velocity of the football, and store it in the variable named ```vy_terminal```.","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"fafe97","input":"## Using odeint\n\n```odeint``` is part of the ```scipy.integrate``` package. It has three required arguments. The first argument is the name of a Python **function** that calculates ${\\mathbf f}({\\mathbf X}, t)$. The second argument is a Python list or numpy array - the entries in this list give the initial conditions of the entries in the vector ${\\mathbf X}$. The final argument is an array containing the time points at which we want to solve the system state.\n\nThe returned value is a two-dimensional array. The first index specifies the time, and the second index specifies the element of the vector ${\\mathbf X}$ at that time. An example will make things clearer!\n\nBelow I solve the pendulum problem again using ```odeint```:","pos":18,"type":"cell"}
{"id":"4cf27f","input":"","pos":32,"type":"cell"}
{"id":0,"time":1731856165793,"type":"user"}
{"last_load":1730728498814,"type":"file"}